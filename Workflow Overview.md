[Home](https://bitbucket.org/sibanez/netfpga-sume-sdnet/wiki/Home)
------

---

Workflow Overview
=================

This page describes the following aspects of the P4-NetFPGA workflow:

* Xilinx P4-SDNet
* P4 Target Architecture for the NetFPGA SUME Platform
* Workflow Steps
* Tips: Writing P4 Programs
* Tips: Writing gen_testdata.py
* P4-NetFPGA Extern Library
* API / CLI
* Limitations

---

Xilinx P4-SDNet
---------------


---

SimpleSumeSwitch Architecture
-----------------------------

The SimpleSumeSwitch is the P4 architecture that is currently defined for the NetFPGA SUME. The architecture description can be found in /opt/Xilinx/SDNet/2016.4/data/p4include/sume_switch.p4 or wherever you have installed Xilinx SDNet. The architecture consists of a single parser, single match-action pipeline, and single deparser. As shown below:

![SimpleSumeSwitch_P4_arch.png](https://bitbucket.org/repo/jp6axo/images/579569362-SimpleSumeSwitch_P4_arch.png)

The sume_metadata, which corresponds to the tuser bus in the SUME reference_switch design, is defined as follows:

    struct sume_metadata_t {
        bit<16> pkt_len; // unsigned int
        bit<8> src_port; // one-hot encoded: {DMA, NF3, DMA, NF2, DMA, NF1, DMA, NF0}
        bit<8> dst_port; // one-hot encoded: {DMA, NF3, DMA, NF2, DMA, NF1, DMA, NF0}
        bit<8> drop;
        bit<8> send_dig_to_cpu; // send digest_data to CPU
        digest_metadata_t digest_data; // data to be sent to the CPU rather than the full packet
    }
    
    // digest metadata to send to CPU
    struct digest_metadata_t {
        bit<8> src_port;
        bit<48> eth_src_addr;
        bit<24> unused;
    }

---

Workflow Steps
--------------

1. Modify `$SUME_FOLDER/tools/settings.sh` to ensure that the `P4_PROJECT_NAME` environment variable is set to the name of the project you would like to work on. Run `$ source settings.sh`

2. **Write your P4 program and commands.txt** - the `commands.txt` file allows you to add entries to tables you have defined in your P4 program.

3. **Write gen_testdata.py**

4. Run the P4-SDNet compiler to generate the resulting HDL and an initial simulation framework: 

    `$ cd $P4_PROJECT_DIR && make`

5. Run the SDNet simulation: 

    `$ cd $P4_PROJECT_DIR/nf_sume_sdnet_ip/SimpleSumeSwitch`

    `$ ./vivado_sim.bash`. 

    Note: you may also run `vivado_sim_waveform.bash` if you would like to fire up the Vivado GUI and see the HDL waveforms (this is a very useful debugging tool).

    If this simulation passes great! If it does not you will need to modify either your P4 program or your `gen_testdata.py` script.

6. Generate the scripts that can be used in the NetFPGA SUME simulations to configure the table entries.

    `$ cd $P4_PROJECT_DIR`

    `$ make config_writes`

7. Wrap SDNet output in wrapper module and install as a SUME library core:

    `$ cd $P4_PROJECT_DIR`

    `$ make uninstall_sdnet && make install_sdnet`

8. Set up the SUME simulation. The `$NF_DESIGN_DIR/test/sim_switch_default` directory contains the `run.py` script which is responsible for running a SUME simulation, check it out. You will see that it reads the test packets generated by the `gen_testdata.py` script in step 3 and applies the packets to SUME interfaces. All we need to do here is copy the `config_writes.py` script generated in step 6 into this directory.

    `$ cd $NF_DESIGN_DIR/test/sim_switch_default && make`

9. Run the SUME simulation:

    `$ cd $SUME_FOLDER`

    `$ ./tools/scripts/nf_test.py sim --major switch --minor default`

    Note: you may also run the above command with the `--gui` option to fire up the Vivado GUI and see the HDL waveforms. Again, a very useful debugging tool.

10. Compile the bitstream:

    `$ cd $NF_DESIGN_DIR && make`

11. Program the FPGA. Copy the bitstream file and `config_writes.sh` script into the `$NF_DESIGN_DIR/bitfiles` directory.

    `$ cd $NF_DESIGN_DIR/bitfiles`

    `$ cp ../hw/project/simple_sume_switch.runs/impl_1/top.bit ./ && mv top.bit ${P4_PROJECT_NAME}.bit`

    `$ cp $P4_PROJECT_DIR/testdata/config_writes.sh ./`

    `$ sudo bash`

    `# bash program_switch.sh`

    Note: Make sure that the configuration writes all succeed. If this is the first time programming the FPGA since the machine was last powered off it may need to be rebooted.

12. Test the design on real hardware! Go to the `$ P4_PROJECT_DIR/sw/CLI` directory and run the `P4_SWITCH_CLI.py` script. This initiates an interactive command line interface that you can use to interact with your switch (i.e. read/write registers, add/remove table entries, etc.). Type `help` to see the list of available commands. 

---

Tips: Writing P4 Programs
-------------------------

This repository currently supports the Xilinx P4_16 frontend compiler. See [here](http://p4.org/wp-content/uploads/2016/12/P4_16-prerelease-Dec_16.html) for a link to the current standard for the P4_16 language. Also go to [P4.org](http://p4.org/) for more information about the open source P4 language consortium.

The Xilinx P4-SDNet specifies a few additional annotations that can be used in P4 programs:

* `@Xilinx_MaxPacketRegion()` - declares the largest packet size (in bits) the parser/deparser needs to support.
* `@Xilinx_MaxLatency()` - the maximum number of clock cycles an extern function needs to complete.
* `@Xilinx_ControlWidth()` - the size in bits of the address space to allocate to an extern function. 
* `@Xilinx_ExternallyConnected()`

See the section "P4-NetFPGA Extern Library" for more information about using and writing extern functions.

---

Tips: Writing gen_testdata.py
-----------------------------

The `gen_testdata.py` script makes heavy use of the python scapy module. Scapy is a very convenient and easy to use packet maniplation library. It allows you to define arbitrary packets and even define your own header types (see `switch_calc_headers.py` for an example). The `gen_testdata.py` script MUST generate:

* `src.pcap` - the packets to feed through the P4 switch
* `dst.pcap` - the packets to expect at the output of the P4 switch
* `Tuples_in.txt` - the metadata associated with each packet in `src.pcap`
* `Tuples_expect.txt` - the metadata associated with each packet in `dst.pcap`

The files listed above are used in the initial SDNet simulation. The file `$SUME_SDNET/bin/sss_sdnet_tuples.py` can be used to facilitate creation of the `Tuples_in.txt` and `Tuples_expect.txt` files for projects that target the SimpleSumeSwitch architecture. For each packet, update `sume_tuple_in` and `sume_tuple_expect` and subsequently call `write_tuples()` to add a line to the `Tuples_*.txt` files.

It is recommended that the `gen_testdata.py` script also generate:

* `nf0_applied.pcap` ... `nf3_applied.pcap`
* `nf0_expected.pcap` ... `nf3_expected.pcap`

These are files that can be used in the SUME simulations. The script should also set the time field for each applied packet so that they can be applied in the correct order for the SUME simulation.

The `${NF_DESIGN_DIR}/test/sim_learning_default/run.py` script runs a SUME simulation. It may make use of the packet traces generated by the `gen_tesdata.py` script or it may create new packets and use those. See [here](https://github.com/NetFPGA/NetFPGA-SUME-public/wiki/NetFPGA-SUME-Simulations) for more details about writing the `run.py` script.

---

P4-NetFPGA Extern Library
-------------------------

Extern functions are designed to allow P4 programers to utilize custom logic in their P4 programs. For the NetFPGA platform, these extern functions must be implemented in HDL (or perhaps some high-level language that generates HDL). In an effort to abstract away the HDL details from the P4 developer, the P4-NetFPGA workflow provides a library of extern functions that can be used in P4 programs. The stateful atomic externs are inspired by the [Domino](http://yuba.stanford.edu/~nickm/papers/domino-sigcomm-16.pdf) atoms. The following tables describes the currently supported extern functions:

**Stateful Atomic Extern Functions**

Name        | Description   
:-----------| :------------
[RW][]      | Read or write state
[RAW][]     | Read, add to, or overwrite state
[PRAW][]    | Either perform RAW or don't perform RAW based on predicate

**Stateless Extern Functions**

Name           | Description   
:--------------| :------------
[LRC][]        | longitudinal redundancy check, simple hash function 
[timestamp][]   | generate timestamp (measure in clock cycles, granularity of 5ns)

[RW]: https://bitbucket.org/sibanez/netfpga-sume-sdnet/wiki/RW%20Extern%20Function
[RAW]: https://bitbucket.org/sibanez/netfpga-sume-sdnet/wiki/RAW%20Extern%20Function
[PRAW]: https://bitbucket.org/sibanez/netfpga-sume-sdnet/wiki/PRAW%20Extern%20Function
[LRC]: https://bitbucket.org/sibanez/netfpga-sume-sdnet/wiki/LRC%20Extern%20Function
[timestamp]: https://bitbucket.org/sibanez/netfpga-sume-sdnet/wiki/Timestamp%20Extern%20Function

---

API / CLI
---------

Both a python and C API are generated by the workflow and and can be used to manipulate the registers and tables instantiated in the P4 program. This workflow currently supports API functions for exact match (CAM) tables and work is currently on going to support API functions for ternary match and LPM match tables as well.

The developer can choose whether they want to write their control-plane in C or in Python. The tools generate a file in the `${P4_PROJECT_DIR}/sw/API` folder called `starter.c`, which is meant to serve as a starter file for developers who want to use the C API.

The tools also generates a file in `${P4_PROJECT_DIR}/sw/CLI` called `p4_tables_api.py` that exposes a python API for developers who prefer that option.

The tools generate an interactive command line environment that can be used to query compile time information about the generated P4 design, as well as interact with the physical switch when it is loaded onto the FPGA. Run: `$ ./P4_SWITCH_CLI.py` to enter the environment, type `help` to see a list of commands and their documentation.

---

Limitations
-----------