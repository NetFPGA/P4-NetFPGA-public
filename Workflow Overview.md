[Home](https://bitbucket.org/sibanez/netfpga-sume-sdnet/wiki/Home)
------

---

Workflow Overview
=================

This page describes the following aspects of the P4-NetFPGA workflow:

* Xilinx P4-SDNet
* P4 Target Architecture for the NetFPGA SUME Platform
* Workflow Steps
* Tips: Writing P4 Programs
* Tips: Writing gen_testdata.py
* P4-NetFPGA Extern Library
* API / CLI

---

Xilinx P4-SDNet
---------------


---

SimpleSumeSwitch Architecture
-----------------------------

The SimpleSumeSwitch is the P4 architecture that is currently defined for the NetFPGA SUME. The architecture description can be found in /opt/Xilinx/SDNet/2016.4/data/p4include/sume_switch.p4 or wherever you have installed Xilinx SDNet. The architecture consists of a single parser, single match-action pipeline, and single deparser. As shown below:

![SimpleSumeSwitch_P4_arch.png](https://bitbucket.org/repo/jp6axo/images/579569362-SimpleSumeSwitch_P4_arch.png)

The sume_metadata, which corresponds to the tuser bus in the SUME reference_switch design, is defined as follows:

```
/* standard sume switch metadata */
struct sume_metadata_t {
    bit<16> pkt_len; // unsigned int
    bit<8> src_port; // one-hot encoded: {DMA, NF3, DMA, NF2, DMA, NF1, DMA, NF0}
    bit<8> dst_port; // one-hot encoded: {DMA, NF3, DMA, NF2, DMA, NF1, DMA, NF0}
    bit<8> drop;
    bit<8> send_dig_to_cpu; // send digest_data to CPU
    digest_metadata_t digest_data; // data to be sent to the CPU rather than the full packet
}

// digest metadata to send to CPU
struct digest_metadata_t {
    bit<8> src_port;
    bit<48> eth_src_addr;
    bit<24> unused;
}

```

---

Workflow Steps
--------------

1. Modify `$SUME_FOLDER/tools/settings.sh` to ensure that the `P4_PROJECT_NAME` environment variable is set to the name of the project you would like to work on. Run `$ source settings.sh`

2. **Write your P4 program and commands.txt** - the `commands.txt` file allows you to add entries to tables you have defined in your P4 program.

3. **Write gen_testdata.py**

4. Run the P4-SDNet compiler to generate the resulting HDL and an initial simulation framework: 

    `$ cd $P4_PROJECT_DIR && make`

5. Run the SDNet simulation: 

    `$ cd $P4_PROJECT_DIR/nf_sume_sdnet_ip/SimpleSumeSwitch`

    `$ ./vivado_sim.bash`. 

    Note: you may also run `vivado_sim_waveform.bash` if you would like to fire up the Vivado GUI and see the HDL waveforms (this is a very useful debugging tool).

    If this simulation passes great! If it does not you will need to modify either your P4 program or your `gen_testdata.py` script.

6. Generate the scripts that can be used in the NetFPGA SUME simulations to configure the table entries.

    `$ cd $P4_PROJECT_DIR`

    `$ make config_writes`

7. Wrap SDNet output in wrapper module and install as a SUME library core:

    `$ cd $P4_PROJECT_DIR`

    `$ make uninstall_sdnet && make install_sdnet`

8. Set up the SUME simulation. The `$NF_DESIGN_DIR/test/sim_switch_default` directory contains the `run.py` script which is responsible for running a SUME simulation, check it out. You will see that it reads the test packets generated by the `gen_testdata.py` script in step 3 and applies the packets to SUME interfaces. All we need to do here is copy the `config_writes.py` script generated in step 6 into this directory.

    `$ cd $NF_DESIGN_DIR/test/sim_switch_default && make`

9. Run the SUME simulation:

    `$ cd $SUME_FOLDER`

    `$ ./tools/scripts/nf_test.py sim --major switch --minor default`

    Note: you may also run the above command with the `--gui` option to fire up the Vivado GUI and see the HDL waveforms. Again, a very useful debugging tool.

10. Compile the bitstream:

    `$ cd $NF_DESIGN_DIR && make`

11. Program the FPGA. Copy the bitstream file and `config_writes.sh` script into the `$NF_DESIGN_DIR/bitfiles` directory.

    `$ cd $NF_DESIGN_DIR/bitfiles`

    `$ cp ../hw/project/simple_sume_switch.runs/impl_1/top.bit ./ && mv top.bit ${P4_PROJECT_NAME}.bit`

    `$ cp $P4_PROJECT_DIR/testdata/config_writes.sh ./`

    `$ sudo bash`

    `# bash program_switch.sh`

    Note: Make sure that the configuration writes all succeed. If this is the first time programming the FPGA since the machine was last powered off it may need to be rebooted.

12. Test the design on real hardware! Go to the `$ P4_PROJECT_DIR/sw/CLI` directory and run the `P4_SWITCH_CLI.py` script. This initiates an interactive command line interface that you can use to interact with your switch (i.e. read/write registers, add/remove table entries, etc.). Type `help` to see the list of available commands. 

---

Tips: Writing P4 Programs
-------------------------

---

Tips: Writing gen_testdata.py
-----------------------------

---

P4-NetFPGA Extern Library
-------------------------


---

API / CLI
---------

Both a python and C API are generated by the workflow and and can be used to manipulate the registers and tables instantiated in the P4 program. This workflow currently supports API functions for exact match (CAM) tables and work is currently on going to support API functions for ternary match and LPM match tables as well.

The developer can choose whether they want to write their control-plane in C or in Python. The tools generate a file in the `${P4_PROJECT_DIR}/sw/API` folder called `starter.c`, which is meant to serve as a starter file for developers who want to use the C API.

The tools also generates a file in `${P4_PROJECT_DIR}/sw/CLI` called `p4_tables_api.py` that exposes a python API for developers who prefer that option.

The tools generate an interactive command line environment that can be used to query compile time information about the generated P4 design, as well as interact with the physical switch when it is loaded onto the FPGA. Run: `$ ./P4_SWITCH_CLI.py` to enter the environment, type `help` to see a list of commands and their documentation.